// Generated by CoffeeScript 1.9.1

/*
 * 工具集
 * @author pjg
 * @data 2015-03-14 16:43:20
 */
var Tools, _, _url, fs, http, https, path, queryStr;

fs = require("fs");

path = require("path");

_ = require("lodash");

_url = require("url");

http = require("http");

https = require("https");

queryStr = require("querystring");

Tools = {};

Tools.getFileSync = function(file, encoding) {
  var _encoding, fileCon, stats;
  _encoding = encoding || 'utf8';
  fileCon = '';
  if (fs.existsSync(file)) {
    stats = fs.statSync(file);
    if (stats.isFile()) {
      fileCon = fs.readFileSync(file, _encoding);
    }
  }
  return fileCon;
};

Tools.getJSONSync = function(file) {
  var data, e, fileCon;
  fileCon = Tools.getFileSync(file);
  data = null;
  if (fileCon) {
    fileCon = fileCon.replace(/\/\/[^\n]*/g, '');
    try {
      data = JSON.parse(fileCon);
    } catch (_error) {
      e = _error;
      console.log(e);
      return null;
    }
  }
  return data;
};

Tools.getUrl = function(url, callback, errback) {
  var HttpType, option, resultData;
  resultData = '';
  option = _url.parse(url);
  HttpType = option.protocol.indexOf('https') > -1 ? https : http;
  return HttpType.get(url, function(res) {
    res.setEncoding('utf8');
    res.on('data', function(data) {
      return resultData += data;
    });
    return res.on('end', function() {
      return callback && callback(resultData);
    });
  }).on('error', function(e) {
    return errback && errback(e.message);
  });
};

Tools.postUrl = function(url, data, headers, callback, errback) {
  var HttpType, option, req, resultData, sendData;
  resultData = '';
  option = _url.parse(url);
  sendData = _.isObject(data) ? queryStr.stringify(data) : data;
  option.method = 'POST';
  option.headers = {
    "Content-Type": 'application/x-www-form-urlencoded',
    "Content-Length": sendData.length
  };
  if (headers) {
    option.headers = _.assign(option.headers, headers);
  }
  HttpType = option.protocol === 'http' ? http : https;
  req = HttpType.request(option, function(res) {
    res.setEncoding('utf8');
    res.on('data', function(data) {
      return resultData += data;
    });
    return res.on('end', function() {
      return callback && callback(resultData);
    });
  });
  req.on('error', function(e) {
    return errback && errback(e.message);
  });
  req.write(sendData + "\n");
  return req.end();
};

Tools.getJSON = function(url, callback, errback) {
  return Tools.getUrl(url, function(data) {
    var e, json;
    json = null;
    try {
      json = JSON.parse(data);
    } catch (_error) {
      e = _error;
      errback && errback(e);
      return false;
    }
    return callback && callback(json);
  }, errback);
};

Tools.deepDo = function(list, deepFunc, cumulateFunc, callback, deep) {
  deep = deep || 0;
  if (!list[deep]) {
    if (callback) {
      callback();
    }
    return;
  }
  return deepFunc(list[deep], function(result) {
    if (cumulateFunc) {
      cumulateFunc(result, list[deep], deep);
    }
    if (deep + 1 < list.length) {
      return Tools.deepDo(list, deepFunc, cumulateFunc, callback, deep + 1);
    } else {
      if (callback) {
        return callback();
      }
    }
  });
};

Tools.exec = function(command, callback) {
  return exec(command, function(error, stdout, stderr) {
    if (stdout) {
      console.log('exec stdout: ' + stdout);
    }
    if (stderr) {
      console.log('exec stderr: ' + stderr);
    }
    if (error) {
      console.log('exec error: ' + error);
    }
    if (callback) {
      return callback();
    }
  });
};

Tools.md5 = function(text) {
  return crypto.createHash('md5').update(text).digest('hex');
};

Tools.mkdirsSync = function(dirpath, mode) {
  if (fs.existsSync(dirpath)) {
    return true;
  } else {
    if (mkdirsSync(path.dirname(dirpath), mode)) {
      fs.mkdirSync(dirpath, mode);
      return true;
    }
  }
};

Tools.objMixin = _.partialRight(_.assign, function(a, b) {
  var val;
  return val = typeof a === 'undefined' ? b : a;
});

module.exports = Tools;
